
import logging
import os
import sqlite3
import time
import threading
import signal
import asyncio
from flask import Flask
from telegram import Update
from telegram.ext import Application, MessageHandler, filters, ContextTypes
from PIL import Image
import imagehash

# –ü—Ä–æ—Å—Ç–æ–π –≤–µ–±-—Å–µ—Ä–≤–µ—Ä –¥–ª—è Render
app_flask = Flask(__name__)

@app_flask.route('/')
def home():
    return "‚úÖ Bot is running!"

def run_flask():
    app_flask.run(host='0.0.0.0', port=5000)

# –ó–∞–ø—É—Å–∫–∞–µ–º Flask –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
flask_thread = threading.Thread(target=run_flask, daemon=True)
flask_thread.start()

# –ü–æ–ª—É—á–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
TOKEN = os.getenv("BOT_TOKEN")
ADMIN_USER_ID = int(os.getenv("ADMIN_USER_ID", "0"))
DB_FILE = "photos.db"

# –í—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
user_last_photos = {}
last_warning_time = {}

def init_db():
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("CREATE TABLE IF NOT EXISTS hashes (hash TEXT PRIMARY KEY)")
    conn.commit()
    conn.close()

def hash_exists(img_hash):
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT 1 FROM hashes WHERE hash = ?", (img_hash,))
    return cursor.fetchone() is not None

def save_hash(img_hash):
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO hashes (hash) VALUES (?)", (img_hash,))
        conn.commit()
    except sqlite3.IntegrityError:
        pass
    conn.close()

async def check_photos_limit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞ —Ñ–æ—Ç–æ"""
    user = update.effective_user
    message = update.message
    
    if user.id == ADMIN_USER_ID or not message or not message.photo:
        return
    
    user_id = user.id
    current_time = time.time()
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if user_id not in user_last_photos:
        user_last_photos[user_id] = []
    
    # –î–æ–±–∞–≤–ª—è–µ–º –≤—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–æ—Ç–æ
    user_last_photos[user_id].append(current_time)
    
    # –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ñ–æ—Ç–æ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–µ–∫—É–Ω–¥
    user_last_photos[user_id] = [t for t in user_last_photos[user_id] if current_time - t <= 10]
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–æ—Ç–æ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–µ–∫—É–Ω–¥
    photo_count = len(user_last_photos[user_id])
    
    # –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –±–æ–ª—å—à–µ 2 —Ñ–æ—Ç–æ –ò —ç—Ç–æ 3-–µ –∏–ª–∏ –ø–æ—Å–ª–µ–¥—É—é—â–µ–µ —Ñ–æ—Ç–æ
    if photo_count >= 3 and user_last_photos[user_id][-1] == current_time:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–ª–∏ –ª–∏ —É–∂–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –≤ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 30 —Å–µ–∫—É–Ω–¥
        last_warn = last_warning_time.get(user_id, 0)
        if current_time - last_warn > 30:
            warning = "üì∏ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ –±–æ–ª—å—à–µ 2 —Ñ–æ—Ç–æ –ø–æ–¥—Ä—è–¥! –û–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å –ø—Ä–∞–≤–∏–ª–∞–º–∏ –≤ –∑–∞–∫—Ä–µ–ø–ª—ë–Ω–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏."
            await message.reply_text(warning, reply_to_message_id=message.message_id)
            last_warning_time[user_id] = current_time

async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–æ—Ç–æ"""
    user = update.effective_user
    message = update.message

    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç —Ñ–æ—Ç–æ
    await check_photos_limit(update, context)
    
    # –ó–∞—Ç–µ–º –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã
    if user.id == ADMIN_USER_ID:
        return

    if not message or not message.photo:
        return

    photo = message.photo[-1]
    file = await context.bot.get_file(photo.file_id)
    file_path = f"temp_{photo.file_id}.jpg"
    await file.download_to_drive(file_path)

    try:
        image = Image.open(file_path)
        img_hash = str(imagehash.average_hash(image))

        if hash_exists(img_hash):
            mention = f"@{user.username}" if user.username else f"[{user.first_name}](tg://user?id={user.id})"
            await update.effective_chat.send_message(
                text=f"‚ö†Ô∏è {mention}, —ç—Ç–æ —Ñ–æ—Ç–æ —É–∂–µ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Ä–∞–Ω–µ–µ!",
                reply_to_message_id=message.message_id,
                parse_mode="Markdown"
            )
            await message.delete()
        else:
            save_hash(img_hash)

    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–æ—Ç–æ: {e}")
    finally:
        if os.path.exists(file_path):
            os.remove(file_path)

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫"""
    logging.error(f"–û—à–∏–±–∫–∞: {context.error}")

def main():
    if not TOKEN:
        raise RuntimeError("‚ùå –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω–∞!")

    logging.basicConfig(level=logging.INFO)
    init_db()

    app = Application.builder().token(TOKEN).build()
    app.add_handler(MessageHandler(filters.PHOTO, handle_photo))
    app.add_error_handler(error_handler)

    # Graceful shutdown –¥–ª—è Render
    def signal_handler(signum, frame):
        logging.info("üö™ –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è...")
        app.stop()
        logging.info("‚úÖ –ë–æ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –∑–∞–≤–µ—Ä—à–∏–ª —Ä–∞–±–æ—Ç—É")
        os._exit(0)

    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    logging.info("‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω —Å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–º –æ—à–∏–±–æ–∫")
    
    try:
        app.run_polling()
    except Exception as e:
        logging.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        os._exit(1)

if __name__ == "__main__":
    main()
